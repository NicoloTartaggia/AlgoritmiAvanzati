\section{Algoritmo di Kruskal con Union-Find}

\begin{lstlisting}[mathescape=true]
KRUSKAL(G):
	A = $\emptyset$
	For each vertex v $\in$ G.V:
		MAKE-SET(v)
	For each edge (u, v) $\in$ G.E ordered by increasing order by weight(u, v):
		if FIND-SET(u) $\neq$ FIND-SET(v):       
			A = A U {(u, v)}
			UNION(u, v)
	return A
\end{lstlisting}

Come per la sua versione naive, l'implementazione di Kruskal tramite l'uso della struttura dati Union Find è un algoritmo greedy che costruisce un MST aggiungendo ad ogni iterazione un nuovo lato di costo minimo all'insieme A se i vertici di questo non fanno già parte dello stesso set.

\subsection{Strutture dati}

	\subsubsection{Graph ed Edge}
		L'implementazione di queste due strutture dati sono equivalenti a quelle utilizzate in AGGIUNGERE SEZIONE per l'algoritmo di Kruskal naive.
	
	\subsection{Union Find}
		La struttura dati Union Find (o Disjoint-Set) mantiene una collezione di insiemi dinamici disgiunti S = \{s\_1\}.
		Viene implementata tramite un array e visualiz zabile come un insieme di alberi diretti, in quanto c'è una relazione padre-figlio, dove ciascun nodo figlio punta al proprio padre.
		Per ciascun elemento di questo array viene salvato un campo parent(x) che, quando viene inizializzato, contiene l'indice dell'array dell'oggetto x.
		Ciascuno di questi insiemi contiene un elemento che lo rappresenta (root).
		La profondità di ciascuno di questi insiemi è pari al numero di elementi compresi tra un dato nodo e la sua root.
		Le operazioni permesse sugli elementi di questa struttura dati sono:
		\begin{itemize}
			\item \textbf{Initialize(x)} o \textbf{Make-Set(x)}: metodo che dato un insieme di oggetti x crea una struttura dati union find creando un insieme per ciascun oggetto x dove il genitore di questo insieme è x stesso. Questa operazione ha complessità lineare sul numero di elementi in x;
			\item \textbf{Find(x)}: ritorna la radice dell'insieme in cui è contenuto l'elemento x passato in input, risalendo di padre in padre fino a quando non trova un self loop, ovvero trova un elemento che punta a se stesso. La sua complessità è proporzionale alla profondità della radice di x, quindi nel peggiore dei casi O(n).
			\item \textbf{Union(x, y)}: prende in input due oggetti e, se questi fanno parte di due insiemi disgiunti diversi, unisce le due componenti connesse che li contengono. Questo viene fatto puntando la radice dell'albero con profondità minore a quella del secondo albero, minimizzando la profondità totale. La complessità union è O(log n) e viene dominata dalla complessità di find.
		\end{itemize}

	\subsection{Implementazione}
		La soluzione del problema è stata implementata nel seguente modo, dato un file del dataset:
		\begin{itemize}
			\item viene inizializzato il grafo G attraverso il costruttore \texttt{Graph()};
			\item viene costruito il grafo G tramite il metodo \texttt{buildGraph()}, al quale viene passato il grafo di input come parametro. La funzione, per ogni tripla (vertice1\_arco\_i, vertice2\_arco\_i, peso\_arco\_i) dell'input, aggiorna le liste di adiacenza di entrambi i vertici attraverso il metodo \texttt{addEdge()} e inserisce l'oggetto arco nella lista degli archi; 
			\item una volta creato il grafo, esso viene fornito come input all'algoritmo \texttt{KruskalUF} che esegue i seguenti passi:
			\begin{enumerate}  				
				\item viene definito A un insieme vuoto, a questo vengono aggiunti ad ogni iterazione i lati che andranno a costituire la soluzione;
				\item viene inizializzata la struttura di insiemi disgiunti U passando l'insieme di nodi del grafo al costruttore, questo crea un insieme per ciascun nodo del grafo;
				\item utilizzando l'algoritmo MergeSort, viene ordinata la lista contenente gli archi del grafo di input in maniera crescente;		
				\item itero i lati in base al loro peso e per ciascuno di questi:
				\item controllo se gli insiemi dei suoi nodi estremi sono gli stessi, se questi sono diversi significa che stanno in due componenti connesse diverse, in tal caso aggiungo il lato al grafo di soluzione A aggiornando la situazione delle componenti connesse
				
			\end{enumerate}
		\end{itemize}
	
	\subsection{Complessità}
	
		Per calcolare la complessità totale dell'algoritmo bisogna tenere in conto:
		\begin{itemize}
			\item il costo O(n) dell'inizializzazione della struttura dati Union Find
			\item il MergeSort con complessità \textbf{O(m log(n))}, dove \emph{m} che indica il numero di archi ordinamento
			\item le operazioni del ciclo, effettuate al massimo m volte:
			\begin{itemize}
				\item le due operazioni di find (2m in totale) con complessità O(m log n)
				\item le n-1 operazioni di union (eseguita ogni volta che viene aggiunto un nuovo lato) con complessità O(n log n)
				\item l'aggiornamento di A ha un costo lineare, quindi con complessità O(m)
			\end{itemize}
		\end{itemize}
		La complessità dell'intero algoritmo è quindi O(m log n).

\pagebreak