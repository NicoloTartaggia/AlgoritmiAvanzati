\section{Algoritmo di Kruskal con implementazione "naive"}
Breve descrizione dell'algoritmo e di cosa fa

\subsection{Strutture dati}
Per l'implementazione dell'algoritmo di Kurskal "naive" sono state impiegate due classi:
\begin{itemize}
	\item \textbf{Graph}: contiene tutte le informazioni relative al grafo in esame:
	\begin{itemize}
		\item n: campo dati che indica numero di vertici;
		\item Le: campo dati che contiene la lista degli archi;
		\item adj: campo dati che contiene le liste di adiacenza tramite un dizionario;
		\item addEdge(u, v): metodo che dati due vertici in input ne aggiunge il collegamento nelle liste di adiacenza di entrambi i vertici;
		\item isConnected(s, t): metodo che dati due vertici in input ritorna "True" se essi sono connessi o "False" se non lo sono;
		\item buildGraph(input): metodo che dato in input il file che contiene la struttura di un grafo suddiviso per linee costruisce un oggetto Graph(n).
	\end{itemize} 
	\item \textbf{Edge}: contiene le informazioni relative ad un arco:
	\begin{itemize}
		\item v1: vertice di partenza;
		\item v2: vertice di arrivo;
		\item weight: peso dell'arco.
	\end{itemize}
	N.B. Non vi è una vera e propria distinzione tra vertice di partenza e vertice di arrivo dal momento che il grafo non è orientato.
\end{itemize}

\subsection{Implementazione}
L'algoritmo di Kruskal in versione "naive" è stato implementato nel seguente modo:
\begin{itemize}
	\item Viene inizializzato il grafo A con lo stesso numero di vertici del grafo di input, che ha lo scopo di tenere traccia degli archi aggiunti al MST;
	\item Viene ordinata la lista contenente gli archi del grafo di input in maniera crescente in base al peso attraverso l'algoritmo mergesort;
	\item Per ogni arco viene controllato che la sua aggiunta al grafo A non porti alla creazione di un ciclo all'interno del medesimo grafo, attraverso il metodo isConnected della classe Graph, ed in caso di esito positivo l'arco viene aggiunto ad A. In questo caso l'algoritmo non verifica che non ci sia un ciclo, ma verifica che non ci sia già un cammino che collega i due vertici in input, perché se così fosse allora l'aggiunta di un ulteriore cammino andrebbe sicuramente a costituire un ciclo in quel grafo. Il metodo isConnected è stato implementato con una variante iterativa di una BFS.
\end{itemize}

\subsection{Complessità}
La complessità dell'intero algoritmo è O(mn). L'algoritmo mergesort ha complessità O(m log m), il ciclo for effettua al più m iterazioni, in cui per ognuna si valuta se il lato in esame può essere aggiunto alla soluzione: in questo caso il controllo sfrutta una variante della BST e quindi ha complessità lineare nel numero di nodi O(n).

\subsection{Ottimizzazioni}
Per ottimizzare l'algoritmo è possibile fermare il ciclo quando A ha n-1 lati.

\pagebreak